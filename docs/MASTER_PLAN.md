# CheDuk: 프로젝트 종합 계획서 (Master Plan)

> 이 문서는 프로젝트의 전체적인 장기 계획을 담고 있습니다. 현재 진행 상황 및 시작 방법은 메인 [README.md](../README.md)를 참고하세요.

> 체스와 장기에서 영감을 받아 영토 개념과 두 가지 승리 조건(수반 격파, 첩자 정보)을 가진 현대 추상 전략 보드게임입니다.

---

## 🚀 프로젝트 개요

| 항목 | 내용 |
|------|------|
| **개발 기간** | 2025.10.21 ~ 진행중 |
| **개발 언어 / 스택** | **프론트엔드**: React (TypeScript), SVG/Canvas (렌더링), Tailwind CSS (스타일링) <br> **백엔드 (멀티플레이어 시)**: Node.js (TypeScript), Express.js, Socket.IO <br> **데이터베이스**: PostgreSQL / MongoDB <br> **핵심 로직**: TypeScript (향후 Rust/WASM 전환 고려) |
| **목적** | 아이디어의 실현 가능성 검증 및 학습 |
| **현 상태** | 개발 초기 단계 (로컬 2인 플레이 MVP 구현 중) |

---

## 1. 개발 목적 및 배경
- **목적**
   1. 독창적인 규칙을 가진 보드게임 '체둑'의 웹 버전을 구현하여 접근성을 높이고, 더 많은 사람이 즐길 수 있도록 한다.
   2. 게임 플레이 데이터를 수집하고 분석하여 게임 밸런스를 검증하고 규칙을 개선한다.
   3. 로컬 플레이 MVP를 시작으로, 최종적으로는 실시간 온라인 대전 및 AI 대전 기능을 갖춘 완성된 웹 애플리케이션을 개발한다.
- **배경**
   체스, 장기, 바둑과 같은 전통적인 추상 전략 게임들은 수 세기 동안 사랑받아왔지만, 현대적인 감각과 새로운 전략적 깊이를 더한 게임에 대한 수요는 항상 존재합니다. '체둑'은 이러한 배경에서 탄생한 아이디어로, 바둑의 '영토' 개념과 체스의 '기물 포획'을 육각 보드 위에서 결합한 독특한 시스템을 가집니다.
   
   특히 '수반 격파'와 '첩자 정보 승리'라는 두 가지 승리 조건은 플레이어에게 다양한 전략적 선택지를 제공하며, 게임의 깊이를 더합니다. 이 프로젝트는 이러한 아이디어를 실제 플레이 가능한 게임으로 구현하고, 그 재미와 가능성을 검증하기 위해 시작되었습니다. 초기 단계에서는 규칙서에 명시된 내용을 코드로 옮겨 최소 기능 제품(MVP)을 만드는 데 집중합니다.

---

## 2. 주요 기능 및 차별점 정리
- **주요 기능**
   1. 육각 타일 보드 및 기물 렌더링
   2. 체둑 규칙에 따른 기물 이동 및 상호작용 로직 구현
   3. 두 가지 승리 조건(수반 격파, 첩자 정보 획득) 판정
   4. 로컬 2인 플레이(Hot-seat) 기능
   5. 실시간 온라인 대전 기능 (향후 목표)
   6. 게임 기록 및 복기(Replay) 기능 (향후 목표)
- **기존 게임과의 차별점**
   1. **하이브리드 전략:** 바둑의 영토 점령 전략과 체스의 기물 기반 전투 전략을 동시에 요구하여 새로운 차원의 심리전을 유도합니다.
   2. **이중 승리 조건:** '수반'을 잡는 물리적 충돌 외에도, '첩자'를 이용한 정보전이라는 비대칭적 승리 루트가 존재하여 게임의 양상을 더욱 다채롭게 만듭니다.
   3. **독창적 기물과 규칙:** 순간이동, 부활, 다른 기물 보호 등 특수한 능력을 가진 '대사', '첩자', '경호원' 같은 독창적인 기물들이 게임에 변수를 더합니다.
   4. **육각 보드:** 사각 보드와 다른 기하학적 특성을 가진 육각 보드는 새로운 이동 경로와 전략적 요충지를 만들어냅니다.

---

## 3. 개발 철학 및 절차

1. **맨땅에 헤딩 (Learning by Doing)**
   - 먼저 작동 가능한 프로토타입을 빠르게 만들어봅니다.
   - 이 과정에서 발생하는 문제와 해결 과정을 기록합니다. (예: `docs/ArchLog.md`)
2. **이론 보강 (Theory Reinforcement)**
   - 구현 중 막히거나 비효율적인 부분이 생기면, 관련 이론이나 언어/프레임워크의 공식 문서를 깊이 학습합니다.
   - 학습한 내용은 별도 문서에 요약하고 코드에 적용한 사례를 남깁니다.
3. **피드백 루프 (Feedback Loop)**
   - 작은 단위의 기능을 계속해서 개선하고 코드를 리팩터링합니다.
   - `실험 → 회고 → 개선` 사이클을 반복하며 프로젝트의 완성도를 높입니다.

---

## 4. 기능 명세
- **게임 준비:**
  - 각 플레이어는 상대가 보지 못하는 상태에서 자신의 '대사'를 배치하여 초기 영토와 선/후공을 결정합니다.
  - 이후, 정해진 순서에 따라 자신의 영토 내에 '첩자'들을 배치합니다.
- **게임 플레이:**
  - 자신의 턴에 기물 하나를 선택하여 규칙에 따라 이동하거나 특수 행동(정보 취득, 캐슬링 등)을 수행합니다.
  - 선택한 기물이 이동할 수 있는 칸이 하이라이트되어 사용자 편의성을 높입니다.
- **게임 상태 관리:**
  - 양측이 획득한 정보 점수, 포획한 기물 목록을 실시간으로 추적하고 표시합니다.
  - 매 턴마다 수반 격파(체크메이트와 유사) 또는 정보 승리 조건 달성 여부를 판정합니다.
  - 3회 동형 반복 등 무승부 조건을 감지합니다.
- **사용자 인터페이스:**
  - 게임 보드, 기물, 플레이어 정보, 턴 표시, 정보 점수, 포획 기물 현황, 게임 로그 등을 명확하게 시각화합니다.

---

## 5. 시스템 아키텍처
- **전체 구조도 요약:**
  - **모노레포:** 프로젝트의 프론트엔드와 핵심 로직을 단일 저장소에서 관리합니다. (향후 백엔드 추가 시 확장)
  - **프론트엔드:** React 기반의 SPA(Single Page Application)로, Vite를 통해 빌드됩니다.
  - **핵심 로직:** 초기에는 TypeScript로 작성하여 프론트엔드와 통합하고, 장기적으로는 성능 향상을 위해 Rust/WASM으로 분리 및 전환을 고려합니다.
  - **백엔드 (멀티플레이어용):** Node.js(TypeScript)와 Express, WebSocket(Socket.IO)을 사용하여 실시간 통신 서버를 구축합니다.
- **프론트엔드:** `React (TypeScript)`, `Vite`, `Tailwind CSS` (스타일링), `SVG/Canvas` (보드 렌더링)
- **핵심 로직:** `TypeScript` (초기), `Rust/WASM` (장기 목표)
- **백엔드:** `Node.js (TypeScript)`, `Express`, `Socket.IO`
- **데이터베이스 (멀티플레이어용):** `PostgreSQL` 또는 `MongoDB`

---

## 6. DB 설계 (멀티플레이어 기능 구현 시)
- **ERD + Schema 구상:**
  - **Users:** `id`, `username`, `password_hash`, `email`, `rating` (ELO), `created_at`
  - **Games:** `id`, `player_one_id` (FK), `player_two_id` (FK), `status` (waiting/ongoing/finished), `winner`, `start_time`, `end_time`
  - **Moves:** `id`, `game_id` (FK), `move_number`, `piece`, `from_pos`, `to_pos`, `notation`, `created_at`
- **각각의 데이터 타입 및 제약조건:**
  - `id`는 `SERIAL PRIMARY KEY` 또는 `UUID`를 사용합니다.
  - 외래 키(FK)를 통해 데이터 무결성을 유지합니다.
  - `username`, `email`은 `UNIQUE` 제약조건을 설정합니다.

---

## 7. 인증 및 보안 (멀티플레이어 기능 구현 시)
- **JWT 기반 인증:** 사용자가 로그인하면 JWT(JSON Web Token)를 발급합니다. 이후 모든 API 요청 및 웹소켓 연결 시 이 토큰을 사용하여 사용자를 인증합니다.
- **HTTPS 적용 과정 설명:** 모든 통신은 SSL/TLS로 암호화하여 중간자 공격을 방지합니다. (예: Let's Encrypt 또는 AWS ACM 사용)
- **서버 측 유효성 검사:** 모든 기물 이동 요청은 서버 측에서 규칙에 따라 유효성을 검증하여 위변조를 방지합니다.
- **CORS 정책:** 백엔드 서버에서 CORS(Cross-Origin Resource Sharing) 정책을 설정하여 허용된 프론트엔드 도메인에서의 요청만 처리합니다.

---

## 8. 페이지/화면 설계
- **메인 화면 (로비):**
  - '새 게임 시작' (로컬/온라인), '게임 참가' 버튼
  - 현재 진행 중인 공개 게임 목록, 플레이어 랭킹 등
- **게임 화면:**
  - 중앙의 게임 보드 및 기물
  - 양쪽 플레이어의 정보(이름, 남은 시간, 획득 정보 점수)
  - 포획한 기물 목록
  - 게임 기록(Notation) 및 채팅창
- **게임 결과 화면:**
  - 승/패/무승부 결과 표시
  - '다시 보기', '로비로 돌아가기' 버튼
- **화면 흐름도:**
  - `메인 화면` -> `(로그인)` -> `게임 모드 선택` -> `(상대 매칭)` -> `게임 화면` -> `게임 종료` -> `결과 확인`

---

## 9. 테스트 전략
- **유닛 테스트:**
  - **핵심 로직:** `Vitest` 또는 `Jest`를 사용하여 각 기물의 이동 규칙, 특수 행동(캐슬링, 정보 취득 등), 승리/무승부 판정 로직을 철저히 테스트합니다.
- **컴포넌트 테스트:**
  - **프론트엔드:** `React Testing Library`와 `Vitest`를 사용하여 보드, 기물 등 각 UI 컴포넌트가 주어진 상태에 따라 올바르게 렌더링되는지 테스트합니다.
- **E2E 테스트:** `Cypress` 또는 `Playwright`를 사용하여 게임 시작, 기물 배치, 몇 번의 턴 진행, 승리 판정까지의 전체 사용자 시나리오를 자동화하여 테스트합니다.
- **API/소켓 테스트 (멀티플레이어):** `Postman`과 전용 테스트 스크립트를 사용하여 백엔드 API 및 웹소켓 이벤트가 정상적으로 동작하는지 검증합니다.

---

## 10. 배포 전략
- **테스트/스테이징 환경:** Arch Linux를 설치한 홈 서버를 활용하여 실제 배포 전 기능 테스트 및 안정성 검증을 진행합니다.
- **프로덕션 환경 (AWS):**
  - **Frontend (React):** 빌드된 정적 파일을 AWS S3에 업로드하고, CloudFront를 통해 CDN으로 서비스하여 빠른 로딩 속도를 보장합니다.
  - **Backend (Node.js):** Docker 이미지를 빌드하여 AWS EC2 또는 Fargate에서 실행합니다.
  - **Database:** AWS RDS for PostgreSQL 등 관리형 데이터베이스 서비스를 사용합니다.
- **CI/CD 파이프라인 (GitHub Actions):**
  - `main` 브랜치에 코드가 푸시(또는 병합)되면 GitHub Actions가 자동으로 `lint`, `test`, `build`를 수행합니다.
  - 모든 단계가 성공하면 빌드된 결과물을 각 프로덕션 환경(S3, EC2/Fargate)에 자동으로 배포합니다.

---

## 11. 개발 일정 및 향후 계획

### 개발 일정
- **MVP 버전 개발 (1~2개월):**
  - 핵심 로직(기물 이동, 승리 판정) 및 로컬 2인 플레이 기능 구현에 집중합니다.
- **베타 버전 개발 (MVP 이후 2~3개월):**
  - 사용자 인증, 실시간 대전을 위한 백엔드 및 데이터베이스를 구축합니다.
  - 기본적인 매치메이킹 기능을 구현합니다.
- **정식 버전 출시:** 랭킹 시스템, 게임 복기 기능 등을 추가하고 UI/UX를 다듬어 정식 출시합니다.

### 향후 계획 (체크리스트)
- [ ] **MVP (로컬 2인 플레이)**: 보드 렌더링, 기물 이동, 승리 조건 판정 구현
- [ ] **멀티플레이어**: 서버-클라이언트 구조, 실시간 대전 구현 (Node.js, Socket.IO 활용)
- [ ] **AI 대전 기능**: Minimax, Alpha-Beta Pruning 등의 알고리즘을 사용한 AI 개발
- [ ] **게임 분석 및 튜토리얼**: 게임 복기 및 분석 기능, 신규 유저를 위한 튜토리얼 추가
- [ ] **오픈소스 공개**: 한국어/영어 룰북 문서화, 커뮤니티 밸런스 논의
- [ ] **핵심 로직 WASM 전환**: TypeScript로 구현된 핵심 게임 로직을 Rust로 재작성 후 WebAssembly로 컴파일하여 성능 최적화 및 Rust 학습 목표 달성
- [ ] **모바일 앱 제작**: 웹 서비스 안정화 후 React Native 등을 사용한 모바일 앱 버전 검토

---

## 12. BM 계획 (Business Model)
- **초기:** 완전 무료로 제공하여 커뮤니티를 형성하고 게임의 저변을 넓히는 데 집중합니다.
- **후원 시스템:** 서버 운영비 및 개발 유지를 위해 'Buy Me a Coffee' 같은 자발적 후원 시스템을 도입합니다.
- **외형 아이템 판매:** 게임 밸런스에 영향을 주지 않는 선에서 다양한 디자인의 보드나 기물 스킨 같은 꾸미기 아이템을 판매하는 것을 고려할 수 있습니다.

---

## 13. 마무리
- **프로젝트 내용 요약**
   CheDuk 프로젝트는 독창적인 규칙을 가진 현대 추상 전략 보드게임을 웹 기술을 통해 구현하는 도전입니다. 로컬 플레이를 시작으로 최종적으로는 AI 및 온라인 대전까지 지원하는 플랫폼을 구축하고, 이 과정에서 Rust/WASM과 같은 새로운 기술을 탐구하고 적용하는 것을 목표로 합니다.
- **참고 자료 모음**
  - [React](https://react.dev/)
  - [Vite](https://vitejs.dev/)
  - [Tailwind CSS](https://tailwindcss.com/)
  - [Node.js](https://nodejs.org/)
  - [Socket.IO](https://socket.io/)
  - [Rust/WASM](https://www.rust-lang.org/what/wasm)
